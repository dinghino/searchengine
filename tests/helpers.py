import json
import os

# from search import utils

TESTS_PATH = os.path.dirname(__file__)

# randomly generated phrases using a markov approach
with open(os.path.join(TESTS_PATH, 'phrases.txt')) as fo:
    PHRASES = fo.read().split('\n')
# Remove duplicates from the loaded phrases, since they have been autogenerated
PHRASES = set(PHRASES)

# realistic dataset of {name, category, subcategory, description} of items
# taken from amazon.com
with open(os.path.join(TESTS_PATH, 'amazon_data.json')) as fo:
    AMAZON_DATA = json.load(fo)


class Phrase:
    """
    Wrapper objects for iterable of strings (produced by a tokenizer) built
    specifically for testing purposes and matching against strings.
    """
    items = []  # quick access. may go when creating stuff

    def __init__(self, words):
        self.words = words
        self.length = len(words.split(' '))
        Phrase.items.append(self)

    @staticmethod
    def setup(contents=PHRASES):
        for phrase in contents:
            Phrase(phrase)
        return Phrase.items

    @staticmethod
    def get_by_length(min_length=0, max_length=1):
        """
        Get an alphabetically sorted list of items that wrap a phrase with
        min_length to max_length words. if max_length equals `-1` all the items
        will be returned.
        """
        if max_length == -1:
            return Phrase.items
        rng = range(min_length, max_length)

        return sorted([i for i in Phrase.items if i.length - 1 in rng])

    def __repr__(self):
        return self.words

    def __len__(self):
        return self.length

    def __lt__(self, other):
        return self.words < other.words

    def __eq__(self, other):  # specific override to match with strings
        return self.words == other


class Item:
    """
    An Item describes a realistic store item. It's used to simulate items of
    an e-commerce and by default.
    """
    items = []

    def __init__(self, name, category, subcategory, description):
        self.name = name
        self.category = category
        self.subcategory = subcategory
        self.description = description
        Item.items.append(self)

    def setup(items=AMAZON_DATA):
        for item in items:
            Item(**item)
        return Item.items

    def __repr__(self):
        return '<Item `{}` [{} ({})]>'.format(
            self.name,
            self.category,
            self.subcategory)
